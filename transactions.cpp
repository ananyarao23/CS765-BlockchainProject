#include "simulator.h"
#include <cstdlib>

using namespace std;

void Peer ::generateTransaction()
{
    // cout << "txn generated by peer " << peerID << endl;
    int timestamp = curr_time + generateExponential(simulator->Ttx*100);
    transactionQueue.push({timestamp, peerID});
}

// we've popped an element from transactionQueue, now need to complete and push to sending queue
void Peer ::broadcastTransaction()
{
    int balance = blockTree[longestChain]->balances[peerID];
    // cout << "txn finalized by peer " << peerID << "with balance" << balance << endl;
    if (balance == 0)
    {
        generateTransaction();
        return;
    }
    total_transactions++;
    simulator->total_transactions++;
    srand(time(0));
    int amt = (rand() % balance) + 1;
    int rcv;
    do
    {
        rcv = (rand() % simulator->numPeers);
    } while (rcv == peerID);

    Transaction *new_txn = new Transaction(peerID, rcv, amt);
    globalTransactions[new_txn->txID] = new_txn;
    for (auto p : neighbours)
    {
        int latency = simulator->calculateLatency(peerID, p, 0.008);
        // cout<<"Latency between sender: "<<peerID<<" receiver: "<<p<<" is "<<latency<<endl;
        
        sendingQueue.push({curr_time + latency, 0, new_txn->txID, p});
    }
    generateTransaction();
}

// we've popped an element from sendingQueue and checked that it's a txn, now need to validate and fwd
void Peer ::receiveTransaction(int txn_id)
{
    // cout << "txn fwd by peer " << peerID << endl;

    if (transactionSet.find(txn_id) == transactionSet.end())
    {
        transactionSet.insert(txn_id);
        memPool.insert(txn_id);
        for (auto p : neighbours)
        {
            int latency = simulator->calculateLatency(peerID, p, 0.008);
            // cout<<"Latency between sender: "<<peerID<<" receiver: "<<p<<" is "<<latency<<endl;
            sendingQueue.push({curr_time + latency, 0, txn_id, p});
        }
    }
}