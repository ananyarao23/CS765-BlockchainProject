#include "simulator.h"
#include <random>
#include <ctime>
#include <cstdlib>
#include <thread>
#include <chrono>

using namespace std;

// int num_peers; // temporary

double procedure(double hash_power){
 // complete
    int I; // interarrival time between blocks
    double mean = I/hash_power,lambda = 1/mean;
    random_device rd;  // Seed source
    mt19937 gen(rd()); // Mersenne Twister generator
    exponential_distribution<double> exp_dist(lambda);

    return exp_dist(gen);
}


void Peer::generateBlock(){
    
    int prevBL = blockchainLeaf;
    Block *blk = new Block(max_block++,blockchainLeaf);
    for(int i = transactionPool.size()-1;i >= 0 && blk->transactions.size() < 1000;i--)
    {
        blk->transactions.push_back(transactionPool[i]); // should i verify the transaction for the utxo
        transactionPool.erase(transactionPool.begin()+i); 
    }
    double T_k = procedure(hash_power);
    // make this thread sleep for T_k seconds
    if(blockchainLeaf == prevBL)
    {
        globalBlocks[blk->BlkID] = blk;
        // should i add this block directly or should I put in my queue as well?
        for(int id=0;id<numPeers;id++){
            if(id == peerID) continue;
            peers[id].blockQueue.push(blk->BlkID);
        }
        coinbase = true;
        // call generate block again in this thread
    }
    else
    {
        // drop out of the thread;
        for(int e:blk->transactions){
            transactionPool.push_back(e);
        }
        max_block--;
        free(blk);
    }
}


void Peer::receiveBlock(){
    // wait for buffer to be filled
    int bID = blockQueue.front();
    blockQueue.pop();
    if(!blockRecord[bID] && verifyBlock(bID))
    {
        blockRecord[bID] = true;
        for(int i=0;i<leafBlocks.size();i++)
        {
            int pID = leafBlocks[i];
            if(pID == globalBlocks[bID].parent_id)
            {
                int depth = blockInfo[pID]->depth + 1;
                blockMetaData *bmd = new blockMetaData(depth,pID);
                blockInfo[bID] = bmd;
                leafBlocks.erase(leafBlocks.begin()+i);
                leafBlocks.push_back(bID);
                if(depth > longestChain)
                {
                    
                    blockchainLeaf = bID;
                    // clear old chain
                    // invoke generate block thread
                }
                // broadcast to connected peers
                for(int id = 0;id < numPeers;id++)
                {
                    if(id == peerID) continue;
                    peers[id].blockQueue.push(bID);
                    // wake up the corresponding receive thread if it's sleeping
                }
                break;
                // go back to processing the queue
            }
        }
    }

}

void Peer::generateTransaction(){
    // generate transactions at interarrival time between transactions generated by any peer is chosen from an exponential distribution whose mean time(Ttx ) can be set a parameter of the simulator
    static random_device rd;
    static mt19937 gen(rd());
    static uniform_real_distribution<double> uniform_dist(0.0, 1.0);
    static uniform_int_distribution<int> amount_dist(0, 50);
    static uniform_int_distribution<int> peer_dist(0, numPeers-1);

    while(true){
        double random = uniform_dist(gen);
        double interarrivalTime = -Ttx * log(1 - random);
        this_thread::sleep_for(chrono::milliseconds(static_cast<int>(interarrivalTime * 1000)));

        int sender_id;
        int receiver_id;
        int amount;
        int txID;
        
        if(coinbase){
            sender_id = -1;
            receiver_id = peerID;
            amount = 50;
            coinbase = false;
            Transaction* tx;
            txID = rand();
            tx = new Transaction(amount, sender_id, receiver_id, txID);
            globalTransactions[txID] = (tx);
            //broadcast_transaction(sender_id, receiver_id, amount);
        }
        else{
            sender_id = peerID;
            if (blockInfo[blockchainLeaf]->UTXOs[peerID] <= 0) continue;

            do {
                receiver_id = peer_dist(gen);
            } while (receiver_id == sender_id);

            amount = amount_dist(gen);
            if (amount > blockInfo[blockchainLeaf]->UTXOs[peerID]) {
                amount = blockInfo[blockchainLeaf]->UTXOs[peerID];
            }
        }

        int txID = rand();
        Transaction* tx;
        tx = new Transaction(amount, sender_id, receiver_id, txID);
        globalTransactions[txID] = (tx);

        transactionPool.push_back(txID);
        transactionQueue.push(txID);
    }
}
void Peer::receiveTransaction(){
    int txID = transactionQueue.front();
    transactionQueue.pop();
    Transaction tx = globalTransactions[txID];
    if(tx.sender_id == -1){
        blockInfo[blockchainLeaf]->UTXOs[tx.receiver_id] += tx.amount;
    }
    else{
        blockInfo[blockchainLeaf]->UTXOs[tx.sender_id] -= tx.amount;
        blockInfo[blockchainLeaf]->UTXOs[tx.receiver_id] += tx.amount;
    }
    // // broadcast to connected peers
    // for(int id = 0;id < numPeers;id++)
    // {
    //     if(id == peerID) continue;
    //     peers[id].transactionQueue.push(txID);
    //     // wake up the corresponding receive thread if it's sleeping
    // }
}



void P2P::start(){
    vector<thread> threads;

    for(Peer& peer: peers){
        threads.emplace_back(&Peer::generateTransaction, &peer);
        threads.emplace_back(&Peer::receiveTransaction, &peer);
        threads.emplace_back(&Peer::generateBlock, &peer);
        threads.emplace_back(&Peer::receiveBlock, &peer);
    }

    for (std::thread& t : threads) 
    {
        t.join();
    }
}

int main(){
    P2P *sim = new P2P();
    sim->start();
}


