#include "simulator.h"

using namespace std;

int num_txns = 0;
int time_stamp = 0;

int txnIDctr = 0;
int blkIDctr = 0;
int curr_time = 0;
priority_queue<vector<int>, vector<vector<int>>, Compare> sendingQueue;
priority_queue<vector<int>, vector<vector<int>>, Compare> transactionQueue;
priority_queue<vector<int>, vector<vector<int>>, Compare> blockQueue;

unordered_map<int, Block *> globalBlocks;             // maps block id to block
unordered_map<int, Transaction *> globalTransactions; // maps transaction id to transaction - populate later on ie when txn is popped from queue

void Peer::setHashPower(double x)
{
    // not fixed yet
    hash_power = x;
}

void Peer::setlowCPU()
{
    lowCPU = true;
}

void Peer::setslow()
{
    slow = true;
}

void P2P::assignSlowFast()
{
    int num = z0 * numPeers / 100;
    vector<int> indices = randomIndices(num, numPeers);
    for (int i : indices)
    {
        peers[i].setslow();
    }
}

void P2P::assignCPU()
{
    int num = z1 * numPeers / 100;
    vector<int> indices = randomIndices(num, numPeers);
    for (int i : indices)
    {
        peers[i].setlowCPU();
    }
}

void P2P::computeHashPower()
{
    double x;
    double coefficient = 0;
    for (int i = 0; i < numPeers; i++)
    {
        if (peers[i].lowCPU)
            coefficient += 1;
        else
            coefficient += 10;
    }
    x = 1.0 / coefficient;
    for (int i = 0; i < numPeers; i++)
    {
        if (peers[i].lowCPU)
            peers[i].setHashPower(x);
        else
            peers[i].setHashPower(x * 10);
    }
}

void P2P::assignPropDelay()
{
    for (int i = 0; i < numPeers; i++)
    {
        prop_delay.push_back(vector<double>(numPeers));
        for (int j = 0; j < numPeers; j++)
        {
            prop_delay[i][j] = sampleUniform(0.01, 0.5);
        }
    }
}

void P2P::assignLinkSpeed()
{
    for (int i = 0; i < numPeers; i++)
    {
        link_speed.push_back(vector<double>(numPeers));
        for (int j = 0; j < numPeers; j++)
        {
            link_speed[i][j] = peers[i].slow || peers[j].slow ? 5 : 100;
        }
    }
}

// ms in megabits
int P2P::calculateLatency(int i, int j, double ms)
{
    double p = prop_delay[i][j]*100;
    double c = link_speed[i][j]*100;
    int d = generateExponential(96 / c);
    return p + d + ms / c;
}

void P2P::start()
{
    // cout << "Starting simulation" << endl;

    Block *genesis_block = new Block(0, -1, {});
    for (int i = 0; i < numPeers; i++)
    {
        // cout << "initial block and transactions generated by peer " << i << endl;
        globalBlocks[genesis_block->BlkID] = genesis_block;
        peers[i].genesis_blk = new treeNode(nullptr, genesis_block);

        peers[i].genesis_blk->depth = 0;
        peers[i].genesis_blk->parent_ptr = nullptr;
        peers[i].genesis_blk->block_id = 0;
        peers[i].blockTree[0] = peers[i].genesis_blk;
        peers[i].blockSet.insert(0);
        peers[i].leafBlocks.insert(0);
        peers[i].generateBlock();
        peers[i].generateTransaction();
    }

    // int numticks = 10000;

    while (curr_time < simTime)
    {
        if(curr_time%100 == 0){
            cout << "Tick " << curr_time << endl;
        }
        // 
        bool blockReady = 0, txnReady = 0, msgReady = 0;
        vector<int> next_blk, next_msg, next_txn;
        if (!blockQueue.empty())
        {
            blockReady = 1;
            next_blk = blockQueue.top();
        }

        while (!blockQueue.empty() && next_blk[0] == curr_time)

        {
            blockQueue.pop();
            int sender = next_blk[2];
            int blkid = next_blk[1];
            if (peers[sender].longestChain == globalBlocks[blkid]->parent_id)
            {
                total_blocks++;
                peers[sender].total_blocks++;
                Block *our_block = globalBlocks[blkid];
                treeNode *parentNode = peers[sender].blockTree[our_block->parent_id];
                treeNode *child = new treeNode(parentNode, our_block);
                // cout << "Balance in block:" << our_block->BlkID << endl;
                child->balances = parentNode->balances;
                for (int txn : our_block->txns)
                {
                    Transaction *tx = globalTransactions[txn];
                    child->balances[tx->sender_id] -= tx->amount;
                    child->balances[tx->receiver_id] += tx->amount;
                }
                child->balances[sender] += 50;
                peers[sender].blockTree[our_block->BlkID] = child;

                peers[sender].leafBlocks.erase(our_block->parent_id);
                peers[sender].leafBlocks.insert(our_block->BlkID);
                peers[sender].maxDepth = child->depth;
                peers[sender].longestChain = blkid;
                // cout << "Updated longest chain with leaf as" << peers[sender].longestChain << endl;

                for (int txn : our_block->txns)
                {
                    peers[sender].memPool.erase(txn);
                }

                peers[sender].broadcastBlock(blkid);
                peers[sender].generateBlock();
            }
            else
            {
                delete globalBlocks[blkid];
                globalBlocks[blkid] = NULL;
            }
            if (!blockQueue.empty())
                next_blk = blockQueue.top();
        }
        if (!transactionQueue.empty())
        {
            txnReady = 1;
            next_txn = transactionQueue.top();
        }
        while (!transactionQueue.empty() && next_txn[0] == curr_time)

        {
            // cout << "Processing transaction" << endl;
            transactionQueue.pop();
            peers[next_txn[1]].broadcastTransaction();
            if (!transactionQueue.empty())
                next_txn = transactionQueue.top();
        }
        if (!sendingQueue.empty())
        {
            msgReady = 1;
            next_msg = sendingQueue.top();
        }
        while (!sendingQueue.empty() && next_msg[0] == curr_time)

        {
            sendingQueue.pop();
            if (next_msg[1] == 0)
            {
                peers[next_msg[3]].receiveTransaction(next_msg[2]);
            }
            else
            {
                peers[next_msg[3]].receiveBlock(next_msg[2]);
            }
            if (!sendingQueue.empty())
                next_msg = sendingQueue.top();
        }
        curr_time++;
    }
}

int main(int argc, char **argv)
{
    if (argc != 7)
    {
        cout << "USAGE: ./{executable} {slow nodes} {slow CPU nodes} {number of peers} {simulation time} {I} {Ttx}" << endl;
        return 1;
    }

    P2P *simulator = new P2P(stoi(argv[3]));
    cout << "P2P constructed" << endl;
    simulator->z0 = stoi(argv[1]);
    simulator->z1 = stoi(argv[2]);
    simulator->numPeers = stoi(argv[3]);
    simulator->simTime = stoi(argv[4]);
    simulator->I = stoi(argv[5]);
    simulator->Ttx = stoi(argv[6]);
    cout << "------------------Starting the simulation-----------------" << endl;
    simulator->start();
    cout << "------------------Simulation ended-----------------" << endl;
    cout << "Total blocks generated: " << simulator->total_blocks/simulator->numPeers << endl;
    cout << "Total transactions generated: " << simulator->total_transactions << endl;
    cout << "Total forks: " << simulator->forks << endl;

    for (auto peer : simulator->peers)
    {
        cout << "Peer ID: " << peer.peerID << " Longest Chain " << peer.maxDepth << endl; 
        cout << "Peer ID: " << peer.peerID << " Blocks generated: " << peer.total_blocks << " Transactions generated: " << peer.total_transactions << endl;
    }
    return 0;
}
